<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NothingAlr8&#39;s Blog</title>
  
  
  <link href="https://nothingalr8.top/atom.xml" rel="self"/>
  
  <link href="https://nothingalr8.top/"/>
  <updated>2022-11-22T10:55:43.536Z</updated>
  <id>https://nothingalr8.top/</id>
  
  <author>
    <name>NothingAlr8</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vim笔记</title>
    <link href="https://nothingalr8.top/2022/11/21/vim%E7%AC%94%E8%AE%B0/"/>
    <id>https://nothingalr8.top/2022/11/21/vim%E7%AC%94%E8%AE%B0/</id>
    <published>2022-11-21T10:12:04.000Z</published>
    <updated>2022-11-22T10:55:43.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vim概述">vim概述</h1><p>vim是一个高门槛的文本编辑器，是由vi升级改良而发展出来的。</p><h1 id="vim键盘图">vim键盘图</h1><p>想要流利地使用vim，就要去记键盘图。</p><h2 id="中文版">中文版</h2><p><img src="vim-cn.gif" /></p><h2 id="英文版">英文版</h2><p>很多时候，结合英文版的键盘图可以提高记忆的效率。</p><p><img src="vim-en.gif" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;vim概述&quot;&gt;vim概述&lt;/h1&gt;
&lt;p&gt;vim是一个高门槛的文本编辑器，是由vi升级改良而发展出来的。&lt;/p&gt;
&lt;h1 id=&quot;vim键盘图&quot;&gt;vim键盘图&lt;/h1&gt;
&lt;p&gt;想要流利地使用vim，就要去记键盘图。&lt;/p&gt;
&lt;h2 id=&quot;中文版&quot;&gt;中文版&lt;/h2</summary>
      
    
    
    
    
    <category term="vim" scheme="https://nothingalr8.top/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令笔记</title>
    <link href="https://nothingalr8.top/2022/11/15/Linux%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/"/>
    <id>https://nothingalr8.top/2022/11/15/Linux%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0/</id>
    <published>2022-11-15T12:03:17.000Z</published>
    <updated>2022-11-15T12:29:03.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起因">起因</h1><p>随着开始使用linux系统，我对于命令的使用也越发频繁，将以此博客来对命令做笔记，并持续更新。</p><h1 id="命令">命令</h1><h2 id="基础命令">基础命令</h2><p>cd：切换目录</p><p>ls：列出当前目录下的文件</p><p>mv：移动</p><p>cp：复制</p><p>rm：移除文件</p><p>touch：创建文件</p><p>mkdir：创建文件夹</p><p>rmdir：移除文件夹</p><p>sudo：使用root权限</p><p>chmod：改变文件权限</p><p>rebot：重启计算机</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;起因&quot;&gt;起因&lt;/h1&gt;
&lt;p&gt;随着开始使用linux系统，我对于命令的使用也越发频繁，将以此博客来对命令做笔记，并持续更新。&lt;/p&gt;
&lt;h1 id=&quot;命令&quot;&gt;命令&lt;/h1&gt;
&lt;h2 id=&quot;基础命令&quot;&gt;基础命令&lt;/h2&gt;
&lt;p&gt;cd：切换目录&lt;/p&gt;
&lt;p&gt;ls：</summary>
      
    
    
    
    <category term="随笔" scheme="https://nothingalr8.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://nothingalr8.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="Linux" scheme="https://nothingalr8.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>随便写写，于期中考之后</title>
    <link href="https://nothingalr8.top/2022/11/15/%E9%9A%8F%E4%BE%BF%E5%86%99%E5%86%99%EF%BC%8C%E4%BA%8E%E6%9C%9F%E4%B8%AD%E8%80%83%E4%B9%8B%E5%90%8E/"/>
    <id>https://nothingalr8.top/2022/11/15/%E9%9A%8F%E4%BE%BF%E5%86%99%E5%86%99%EF%BC%8C%E4%BA%8E%E6%9C%9F%E4%B8%AD%E8%80%83%E4%B9%8B%E5%90%8E/</id>
    <published>2022-11-15T11:15:48.000Z</published>
    <updated>2022-11-22T10:58:31.296Z</updated>
    
    <content type="html"><![CDATA[<p>期中考结束了，我也开始顺应了大学的生活节奏，有很多想法。</p><h1 id="大学生活">大学生活</h1><p>首先聊聊我现在对大学生活的看法吧。</p><p>关于大学的生活，是我高中那时十分向往的。对于大学自由生活的渴望或许是我高三那年能坚持下来的原因之一，虽然有许多不尽人意，但都毕竟过去了，也没必要揪着不放了。</p><p>大学生活，是自由的，让我高兴。但大学生活，也没有那么自由，没有我想象的那般美好。</p><p>现在的我，一样被学业的重担压着，一样需要学习一堆我不喜欢的基础课程，甚至需要去应付一些所谓的水课，除此之外，我还要管理好我的生活，学会独立生活。</p><p>不知不觉中，我幻想的那种自由的大学生活似乎离我远去了。我发现生活中的琐事越来越多，我似乎变得越来越忙了。</p><p>大学学习也没有我想的那么自由。</p><p>一样要学习自己不喜欢的课程，一样要应付考试。</p><p>在大学中，我不想在乎分数，我不想在意绩点，更不想去理会奖学金，我想要活出自己的状态，去做自己真心想做的事，但我发现这好难啊。</p><h1 id="迷茫">迷茫</h1><p>我发现自己又迷茫了，就像我开始好奇世界为什么存在一样，像我疑惑我为了什么而活一样。</p><p>我前几次的迷茫都没有结果，我仍然不知道世界为什么存在，我还是不知道我为了什么而活。我想，这次对于未来的迷茫我一样不会思考出什么东西。我想，我也开始接受迷茫了，但是在迷茫时，心情一样较为低迷。</p><p>我为什么迷茫，我问我自己。我想，是觉得自己一事无成吧。</p><p>我希望把时间用在自主学习后端相关的知识上，但发现我好像什么都没学，对于一个项目，仍然一无所知。</p><p>我似乎花了很多时间在学习上，但我似乎什么都没学，都在浪费时间。</p><p>对于迷茫，我没有什么办法，只是接受它，并不希望去解决它，我想最后一样没有什么结果。慢慢来吧，时间一样会治好我的迷茫。</p><h1 id="音乐">音乐</h1><p>我在迷茫这段时间里，听了很多摇滚，我发现我越来越喜欢摇滚了。</p><p>我没有什么音乐的基础，但我迫切地希望自己能学一门乐器，或许摇滚相关的乐器是我最后的选择。</p><p>寒假，我希望我能开始。</p><h1 id="关于博客">关于博客</h1><p>我已经有半个月没有写博客了，一是为了准备期中考，但主要还是我有些迷茫了。</p><p>对于博客，我似乎有很多想上去的，但是每当开写之时，又会不知道写些什么，愣在电脑前。而就算开写了，我发现我缺失了表达自我的能力，很多内容无法表达出来，表达出来也索然无味。我有一次察觉到了我文笔之差，今后还要多阅读。</p><p>今天以后，我应该会重新继续写博客，每天都写，或多或少都要写点，哪怕只写一行。</p><h1 id="最后">最后</h1><p>最后，附上我下一阶段的学习以及博客的规划。</p><ol type="1"><li>继续学习Go语法，补全博客</li><li>学习go-zero服务，希望能参与到项目中去，并写一点博客</li><li>熟悉linux命令并写归纳的博客</li><li>学习vim的具体使用</li><li>学习MySQL</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;期中考结束了，我也开始顺应了大学的生活节奏，有很多想法。&lt;/p&gt;
&lt;h1 id=&quot;大学生活&quot;&gt;大学生活&lt;/h1&gt;
&lt;p&gt;首先聊聊我现在对大学生活的看法吧。&lt;/p&gt;
&lt;p&gt;关于大学的生活，是我高中那时十分向往的。对于大学自由生活的渴望或许是我高三那年能坚持下来的原因之一，虽然</summary>
      
    
    
    
    <category term="随笔" scheme="https://nothingalr8.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://nothingalr8.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Linux初体验</title>
    <link href="https://nothingalr8.top/2022/11/04/Linux%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>https://nothingalr8.top/2022/11/04/Linux%E5%88%9D%E4%BD%93%E9%AA%8C/</id>
    <published>2022-11-04T03:03:17.000Z</published>
    <updated>2022-11-15T11:13:09.132Z</updated>
    
    <content type="html"><![CDATA[<p>已经将近一个星期没有写博客了，这段时间我一直在折腾Linux，现在已经是我正式使用Linux的第5天了。现在，我用这篇博客来讲讲我这几天的体验与感受。</p><h1 id="安装linux">安装Linux</h1><p>我选择的是Ubuntu 22.04.1LTS，其实我也不明白我应该选哪个发行版，只是听说Ubuntu适合初学者尝试，也就稀里糊涂地开始了。</p><p>刚开始的过程比较顺利，下载安装包，将文件刻入到U盘，然后进入BIOS，以U盘启动，这几步和安装Windows无异。</p><p>但在安装系统时，一直报错，一开始我以为是系统盘文件不完整导致，然后就莫名其妙地进入了安装界面，但是，提示让我关闭微软的bitlocker(对硬盘加密，以起到电脑丢失数据不泄露的作用，我也不知道到底有没有用，电脑出厂开启了)。</p><p>我顺利关闭了bitlocker，然后又无法进入安装界面了，又是反复的尝试，反复的报错。</p><p>最后，我开始尝试更改一些bios设置。机缘巧合下，我把独显直连开了，然后就进去了，我也不知道这是不是玄学。</p><h1 id="遇到的问题">遇到的问题</h1><p>目前的很多软件都没有linux版本，需要使用wine等软件来模拟windows环境。</p><p>这里我要点名批评一下腾讯，QQ和微信都没有linux版(不要和我说QQ有linux版，那和屎一样的东西能用吗)。</p><p>但是wine的配置也比较麻烦，使用中也会遇到这样或是那样的bug。我就遇到一个我还没有解决的问题：使用微信时，切换窗口会留下窗口阴影，十分难受。</p><p>而要解决这个问题，也许需要编写一个杀死窗口进程的软件，然后设置为开机启动，以后再搞吧。</p><h1 id="仍未解决">仍未解决</h1><p>在安装以及配置环境的时候，我都没有注意到一个问题——我的电脑没有声音了。</p><p>经过测试，链接耳机，或是蓝牙设备的时候是可以正常播放声音的，但是无法使用笔记本自带的外放设备。</p><p>经过长时间的尝试，我试过了能找到的所有方法，依旧未解决。考虑到我目前对外放声音也没有需求，就先放弃了。（或许可以外接音响，说不定就行呢）</p><h1 id="使用体验">使用体验</h1><blockquote><p>需要折腾，这是我对linux最贴切的概括。</p></blockquote><p>在我这段并不长的使用中，我很明显的感受到了Linux系统的缺点，以及一些优点。</p><h2 id="缺点">缺点</h2><h3 id="学习成本较高">学习成本较高</h3><p>我想，linux之所以无法像windows那样流行，就是因为学习成本过高。</p><p>尽管有了图形化界面，linux仍然无法像windows那样只用图形化界面就可以解决日常使用的绝大多数问题，依然需要学习一些操作命令，通过命令行来解决问题。</p><h2 id="优点">优点</h2><p>说实话，我现在并没有非常明显的感受到linux的优点，毕竟还没有使用多久。</p><p>目前我只感受到了两点：</p><ol type="1"><li>我的笔记本的续航变好了，在使用linux环境下，我关闭了独立显卡的使用后，我的电池可以撑大约5个小时，比windows多出2个小时。</li><li>后台运行内存大量减小，内存剩余明显变多了。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;已经将近一个星期没有写博客了，这段时间我一直在折腾Linux，现在已经是我正式使用Linux的第5天了。现在，我用这篇博客来讲讲我这几天的体验与感受。&lt;/p&gt;
&lt;h1 id=&quot;安装linux&quot;&gt;安装Linux&lt;/h1&gt;
&lt;p&gt;我选择的是Ubuntu 22.04.1
LTS，</summary>
      
    
    
    
    <category term="随笔" scheme="https://nothingalr8.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="https://nothingalr8.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
    <category term="Linux" scheme="https://nothingalr8.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的Go(12)-方法</title>
    <link href="https://nothingalr8.top/2022/11/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go(12)-%E6%96%B9%E6%B3%95/"/>
    <id>https://nothingalr8.top/2022/11/01/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go(12)-%E6%96%B9%E6%B3%95/</id>
    <published>2022-11-01T07:35:23.000Z</published>
    <updated>2022-11-22T10:58:17.047Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    <category term="Go" scheme="https://nothingalr8.top/categories/Go/"/>
    
    <category term="从零开始的Go" scheme="https://nothingalr8.top/categories/Go/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go/"/>
    
    
    <category term="Go" scheme="https://nothingalr8.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的Go(11)-函数</title>
    <link href="https://nothingalr8.top/2022/10/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go(11)-%E5%87%BD%E6%95%B0/"/>
    <id>https://nothingalr8.top/2022/10/31/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go(11)-%E5%87%BD%E6%95%B0/</id>
    <published>2022-10-31T09:35:23.000Z</published>
    <updated>2022-11-22T10:58:12.439Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数规则">函数规则</h1><p>除<code>main</code>函数与<code>init</code>函数之外，所有函数都可以有参数与返回值。</p><p>当函数执行到代码的最后一行( <code>&#125;</code>之前)或<code>return</code>语句时退出，<code>return</code>后面可以带有任意个参数，作为函数的返回值。</p><p>要注意的是 <code>&#123;</code>需要和函数的名字写在同一行，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//错误的定义：</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span><br>&#123;<br>&#125;<br><br><span class="hljs-comment">//正确的定义：</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>若函数要被在其他包中调用，要首字母大写。</p><h1 id="函数的分类">函数的分类</h1><p>在Go语言中共有3种函数类型：</p><p>对于Go语言中函数类型的分类，各有各的不同，而我将go中的函数分为以下4种：</p><ul><li>特殊函数</li><li>普通函数</li><li>匿名函数</li><li>方法(下一节再讲)</li></ul><h2 id="特殊函数">特殊函数</h2><p>go中共有两种较为特殊的函数，为<code>main</code>函数和<code>init</code>函数。</p><h3 id="main函数">main函数</h3><p>像其他语言一样，go语言也有<code>main</code>函数，也是从<code>main</code>函数开始运行程序。</p><p>在整个程序中，应该有且仅有一个<code>main</code>函数，出现多个会导致程序运行出错。</p><p>在go中，<code>main</code>函数所在的位置不太重要，但是鉴于可读性的需求，最好把<code>main</code>函数放在程序的最前面，或是单独写成一个源文件。</p><h3 id="init函数">init函数</h3><p>除<code>main</code>函数之外，go中另一种非常特殊的函数为<code>init</code>函数。</p><p><code>init</code>函数不能够被调用，而是会在每个包完成初始化后自动执行，并且它的执行优先级高于<code>main</code>函数。</p><p>每个源文件最多只能有一个<code>init</code>函数，在多个包中的<code>init</code>函数会按照包的依赖关系依次执行。</p><h2 id="普通函数">普通函数</h2><p>定义方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">name</span><span class="hljs-params">(arg1 type1, arg2 type2, ..., argn typen)</span></span> (functype1, functype2, ..., functypen)&#123;<br>    <span class="hljs-comment">//do something</span><br>    <span class="hljs-keyword">return</span> res1, res2, ..., resn<br>&#125;<br></code></pre></td></tr></table></figure><p>name为函数名</p><p>functype为函数返回值的类型，可以省略，若有则函数必须要有返回值，与返回值数量对应</p><p>arg为函数的参数，可以是多个，也可以没有</p><p>type为接受参数的类型，可以省略</p><p>res为函数返回值，可以是多个，也可以没有</p><h2 id="匿名函数">匿名函数</h2><p>当我们不希望给函数起名字时，可以使用匿名函数，这样的函数不能独立存在，但是可以赋值给变量，然后通过变量名对函数进行调用，当然也可以直接调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">func() &#123;</span><br><span class="hljs-comment">fmt.Println(&quot;Hello!&quot;)</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">不能独立存在，但可以像下面这么使用</span><br><span class="hljs-comment">*/</span><br><br>a := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;Hello!&quot;</span>)<br>&#125;<span class="hljs-comment">//a成了一个闭包，后面会讲</span><br>a()<br><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Hello!&quot;</span>)<br>&#125;()<span class="hljs-comment">//在函数最后加上()可以直接调用</span><br><br></code></pre></td></tr></table></figure><h1 id="defer和追踪">defer和追踪</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;函数规则&quot;&gt;函数规则&lt;/h1&gt;
&lt;p&gt;除&lt;code&gt;main&lt;/code&gt;函数与&lt;code&gt;init&lt;/code&gt;函数之外，所有函数都可以有参数与返回值。&lt;/p&gt;
&lt;p&gt;当函数执行到代码的最后一行( &lt;code&gt;&amp;#125;&lt;/code&gt;
之前)或&lt;code&gt;re</summary>
      
    
    
    
    <category term="Go" scheme="https://nothingalr8.top/categories/Go/"/>
    
    <category term="从零开始的Go" scheme="https://nothingalr8.top/categories/Go/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go/"/>
    
    
    <category term="Go" scheme="https://nothingalr8.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>我与游戏</title>
    <link href="https://nothingalr8.top/2022/10/30/%E6%88%91%E4%B8%8E%E6%B8%B8%E6%88%8F/"/>
    <id>https://nothingalr8.top/2022/10/30/%E6%88%91%E4%B8%8E%E6%B8%B8%E6%88%8F/</id>
    <published>2022-10-30T12:06:25.000Z</published>
    <updated>2022-11-21T09:38:35.310Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉，我已经大一了，我也已经玩了十多年的游戏了。而悄无声息中，游戏也成为了我生活的一部分，无法分隔。回想我与游戏的故事，我有太多可以说的了。我的游戏史，在无形之中记录了我人生的轨迹。我想通过这篇博文，来讲述一下我与游戏的故事，并穿插一些我对游戏与生活的看法。</p><h1 id="初识游戏">初识游戏</h1><p>身为一个零零后，我的游戏启蒙并不是游戏机，而是家用电脑。</p><p>说实话，我已经记不清我家里是什么时候有电脑的了，好像打我记事起，便有了。我只记得，在当时，在我和小伙伴中，只有我家有一台电脑，一台安装了WindowsXP系统的电脑。在几年前，我闲来无事，便把电脑拆了，发现这竟然是一台联想的品牌机，用的一颗奔腾处理器(具体是什么，我已经记不清了)，还有独显，以及在现在家用电脑上一般都见不到的独立声卡(现在的大多数都集成在主板上了，非专业的不需要独立声卡)。</p><p>应该和许多人一样，4399、7k7k等小游戏网站，是童年中不可磨灭的记忆。在当时，4399中的各种游戏成了我与小伙伴们周末的伴侣，一到周末，我家就成了聚集地，我们开始玩各种多人合作小游戏，像是拳皇(当时大家都不会玩，都是一通乱按)，像是造梦西游等等。那时的日子，真是充满快乐，至今想起仍记忆犹新。而后来，渐渐的，小伙伴们家中也渐渐有了电脑，我们也因为学业问题，聚得越来越少。现在，我们各奔东西，想要在聚在一起已经不再现实了。</p><p>统治我童年的，不仅有flash小游戏，还有各种网游。当时，在小伙伴的建议下，我接触了CF，LOL等腾讯网游。我还依稀记得当时看到游戏界面的“未满18周岁禁止游玩”字样时的样子，我在电脑前犹豫了几分钟后，才进入游戏，并用网上找的身份证号来通过验证。现在看来，当时的实名认证监管是真的松，而现在的小学生日子可真不好过。</p><p>我在童年时期，就见到了网游的圈钱能力。CF一把英雄级武器卖4位数，买的人还不少。当时上小学的我就看到我的一个小伙伴的同学，在CF里冲了好几万(听说人家小学一个月零花钱就有好几千)，光是一样的英雄级武器就有好几把。我也算是第一次见识了有钱人，感受到了世界的贫富差异与社会的不公平。</p><p>虽说，网游对我充满吸引力，但我玩的还算比较少，没有太多的感情。</p><p>在这一阶段，我也刚刚接触到了单机游戏，但当时，我对这类游戏的概念都搞不清。我尝试着自己从盗版网站上下了刺客信条1来玩，但是，不知道为什么，我的游戏没有汉化，我也不会搞，就没有玩下去了。当多年以后，我重新接触到刺客信条系列游戏时，已经是奥德赛了，但是，奥德赛却只能给我短暂的几十小时的快乐游戏时光了，当然，这都是后话了。</p><p>而在我小学四五年级时，我接触了对我人生具有非凡意义的一款游戏——Minecraft。</p><h1 id="我与minecraft">我与Minecraft</h1><p>我的初中三年，算是我接触游戏种类比较少的时期，我的大多数时间都是与minecraft度过的。</p><p>我与minecraft相识是在小学，当时我没有正版概念，从网络上寻找各种版本与整合包来玩，在当时，我只是稀里糊涂地玩，直到开始接触各种自媒体。</p><p>好像是在初中那会，我开始将大量的时间放在看自媒体视频上，主要都是与minecraft相关的，包括游戏实况，游戏教学，模组介绍等。也是通过自媒体，我开始真正了解这款游戏。</p><p>我开始接触模组(Mod)、资源包(材质包)、光影，了解整合包的概念，也开始接触到社区(虽然是游戏社区)。我觉得这一阶段，我学习到了特别特别多的东西，不单单是如何安装模组、材质包、光影、如何做一个简单的整合包，还有通过社区、通过网络寻找教程去解决问题的方法，这对我现在的自主学习帮助非常大。</p><p>而也是通过minecraft，我开始了解了什么是正版游戏。我也迫切地希望成为一个正版游戏玩家，但碍于当时我没有网络支付手段，我并没有买正版minecraft。到我买minecraft正版，已经是高二了，minecraft玩的已经比较少了。</p><h1 id="爆发期">爆发期</h1><p>在初二，我家里就已经在安排着搬家的事，到了初三，才搬了进去(旧电脑没有搬)，我也有了一个全新的房间。我希望我的房间里有一台电脑，但是当时初三的中考，我发挥失常，没有得到理想的成绩，没好意思。</p><p>在这期间，我一直想着买电脑这件事，因此开始关注一些装机博主。讲真的，这段经历让我收获了很多。我开始了解了一台电脑的组成配件，也明白了怎么装电脑（后来我也确实是自己装起来的），我在心中为自己写了一份配件清单，想着攒钱买电脑。</p><p>直到高一上学期结束，我拿到了奖学金，加上之前攒的钱与父母的补贴，才算真正实现了我这一小目标。当时我希望从网上买配件自己组装，但我的父母并不信任我，认为我只是从同学那道听途说，强拉着我去电脑城买。但好歹我是懂一点东西的，并没有被宰，但现在想想依然被小坑了一把。当时已经出了20系显卡，我因为资金原因还是选择了10系，我希望买新出的1660super，商家硬说没货了，把库存的1660塞给了我。最后，在商家的店里，我顶着父亲的反对，是自己装的电脑。</p><p>而紧接着来的便是疫情与网课。当时，我和我的父母都很幸庆，觉得电脑买的真及时。我父母觉得我有了电脑，就不用盯着小小的手机屏幕上网课，保护了我的眼睛；而我则觉得，网课期间真是一段用来打游戏的好时间，有了双设备(手机+电脑)真是如虎添翼。</p><p>现在想想，疫情期间我真的玩了好多种类的游戏。我开始接触宫崎英高，从通关只狼到尝试魂2(当时没有通关，被劝退了，魂2太难了，我觉得是魂系列最难的)。我开始玩一些独立游戏，从一边听网课一边玩正版PVZ，到熬夜玩杀戮尖塔。</p><p>后来，我便是真正喜欢上了单机游戏，也开始接受花钱买正版游戏，也开始对情怀付费。我已经记不清玩了多少游戏了，就提几个因为某种原因印象较深的游戏吧。</p><p>第一个是老滚5(上古卷轴5)，这是我这阶段玩的为数不多的盗版游戏了(有些游戏国内并没有正规购买渠道，懂得都懂)。并不是因为我买不起正版，不想买正版。是我已经买了正版了，但是正版体验并没有盗版好，这是一件挺离谱的事。盗版可以直接下别人调试好的整合包，直接变身少女卷轴。而正版加模组有一堆问题，不是轻易可以解决的。这款游戏当时对我来说是挺震撼的(指打了模组的)，其实B社这家公司对我来说也是挺震撼的，<del>可以有那么多bug，还需要用玩家制作的模组来修bug。</del>但老滚这种游戏非常对我的胃口，老滚6或许是我现在最期待的游戏了。我并没有对它报太高的希望，只希望想打了模组的老滚5一样(老滚5装了太多模组会有各种问题)，但没有太多影响体验的bug就行。</p><p>赛博朋克2077算是另一款我印象非常深的游戏，也是第一款我全款预购的游戏。2077的宣传与营销策略做的是在是太好了，加上之前巫师3的良好体验，我对CDPR的好感也比较高，我就上钩了。宣传的游戏与实际体验的游戏完全不是一个东西，而且游戏的优化实在是太烂了。尽管更新了许多补丁，不断优化，2077在今天仍然是一款超前的游戏(指对配置的要求)。哪怕是恐怖的4090，不借助DLSS，也无法在4k全高画质下把这游戏跑到100帧以上。而通过这次的经历，我也得到了一个教训——不要乱预购游戏，等出来之后看评价再买。后来，我全款预购的游戏也就只有仁王2与艾尔达法环了，前者是因为看过了大量的实况(仁王2是PS5移植到PC的)，后者是因为宫崎英高。</p><p>还有就是传说之下，一款挺惊艳的独立游戏。从这款游戏开始，我明白了一个人也可以做出让世人震惊的游戏，心中埋下了一颗做独立游戏的种子(现在或许已经被深深掩埋了起来吧)。也是从这款游戏开始我开始喜欢独立游戏，也相信TGA，开始玩一下拿了TGA的游戏。但是2020年这一年，算是告诉我了所有奖项都tm的是一坨狗屎。</p><p>在这阶段，我还是开始关注游戏设计了(毕竟想做游戏)，也阅读了2本关于游戏的专业书籍，有些不止于游戏的收获吧。</p><h1 id="现阶段">现阶段</h1><p>现在说实话，比起过去，我已经算是玩游戏玩的比较少了。一是没有什么时间，大学并没有想象的那么轻松，我还需要学习很多东西，目标与自身存在着不小的差距。还有就是我已经玩不太动游戏了。</p><p>我是真的玩不动什么游戏了，似乎是得了“电子阳痿”？我还记得我以前“沉迷游戏”的样子，玩上一款小小的游戏可以让我开心半天，是我内心对游戏的标准提高了吗？我想，是节奏变快了，我无法静下心来真真欣赏体验游戏了。</p><p>但是我对游戏的兴趣没有削减，依然渴望去接触新的游戏。我希望通过写博客的方式，将我对游戏的体验以及感悟记录下来，希望我能一直对游戏充满热情，重新找回游戏的状态。</p><p>再者，我就是希望自己买一台Switch，开始我对任天堂独占游戏的体验。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;不知不觉，我已经大一了，我也已经玩了十多年的游戏了。而悄无声息中，游戏也成为了我生活的一部分，无法分隔。回想我与游戏的故事，我有太多可以说的了。我的游戏史，在无形之中记录了我人生的轨迹。我想通过这篇博文，来讲述一下我与游戏的故事，并穿插一些我对游戏与生活的看法。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="随笔" scheme="https://nothingalr8.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="游戏" scheme="https://nothingalr8.top/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="随笔" scheme="https://nothingalr8.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的Go(10)-结构体</title>
    <link href="https://nothingalr8.top/2022/10/29/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go(10)-%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>https://nothingalr8.top/2022/10/29/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go(10)-%E7%BB%93%E6%9E%84%E4%BD%93/</id>
    <published>2022-10-29T09:35:23.000Z</published>
    <updated>2022-11-22T10:58:08.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="结构体">结构体</h1><p>定义格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> identifier <span class="hljs-keyword">struct</span> &#123;<br>    field1 type1<br>    field2 type2<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> s <span class="hljs-keyword">struct</span> &#123;<br>a <span class="hljs-type">int</span><br>b <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这将定义一个名叫<code>s</code>的结构体，结构体包含了2个<code>int</code>字段，分别为<code>a</code>和<code>b</code>。</p><p>使用以下命令来声明一个<code>s</code>结构体z，并使用结构体<code>x</code>的字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x s<br>x.a = <span class="hljs-number">50</span><br>x.b = <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>也可以通过new()来创建一个结构体指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">x := <span class="hljs-built_in">new</span>(s)<span class="hljs-comment">//创建一个结构体指针</span><br><span class="hljs-comment">//等同于：</span><br><span class="hljs-comment">//var x *s</span><br><span class="hljs-comment">//x = new(s)</span><br></code></pre></td></tr></table></figure><p>可以通过以下代码看出两者的区别：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> s <span class="hljs-keyword">struct</span> &#123;<br>a <span class="hljs-type">int</span><br>b <span class="hljs-type">int</span><br>&#125;<br>x1 := <span class="hljs-built_in">new</span>(s)<br>x2 := s<br>fmt.Println(x1)<br>fmt.Println(x2)<br></code></pre></td></tr></table></figure><p>值得注意的是，也可以直接使用以下命令对引用结构体指针的字段(同结构体)：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">x1 := <span class="hljs-built_in">new</span>(s)<br>x1.a = <span class="hljs-number">50</span><br>(*x1).b = <span class="hljs-number">100</span><span class="hljs-comment">//这么做也是可以的</span><br></code></pre></td></tr></table></figure><h2 id="使用工厂方法创建结构体">使用工厂方法创建结构体</h2><p>Go中常常使用工厂方法来创建结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> File <span class="hljs-keyword">struct</span> &#123;<br>    fd      <span class="hljs-type">int</span>     <span class="hljs-comment">// 文件描述符</span><br>    name    <span class="hljs-type">string</span>  <span class="hljs-comment">// 文件名</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewFile</span><span class="hljs-params">(fd <span class="hljs-type">int</span>, name <span class="hljs-type">string</span>)</span></span> *File &#123;<br>    <span class="hljs-keyword">if</span> fd &lt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> &amp;File&#123;fd, name&#125;<br>&#125;<br><br>f := NewFile(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;./test.txt&quot;</span>) <br></code></pre></td></tr></table></figure><h2 id="带标签的结构体">带标签的结构体</h2><p>在结构体后可以添加标签：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> File <span class="hljs-keyword">struct</span> &#123;<br>    fd      <span class="hljs-type">int</span>     <span class="hljs-string">&quot;1&quot;</span><br>    name    <span class="hljs-type">string</span>  <span class="hljs-string">&quot;2&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用反射<code>reflect</code>来使用标签，这将在反射中提到。</p><h2 id="匿名字段">匿名字段</h2><p>结构体可以使用匿名字段，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> File <span class="hljs-keyword">struct</span> &#123;<br>    a      <span class="hljs-type">int</span>     <br>    <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但是，同一个类型的匿名字段最多只有一个，使用以下代码来使用这一字段：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-built_in">new</span>(File)<br>s.a = <span class="hljs-number">10</span><br>s.<span class="hljs-type">int</span> = <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><h2 id="内嵌结构体">内嵌结构体</h2><p>在结构体中也可以含有一个结构体，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> s1 <span class="hljs-keyword">struct</span> &#123;<br>    a<span class="hljs-type">int</span>     <br>    b<span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> s2 <span class="hljs-keyword">struct</span> &#123;<br>    c<span class="hljs-type">int</span><br>    s1<br>&#125;<br></code></pre></td></tr></table></figure><p>在名字无冲突的情况下，可以使用这样调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-built_in">new</span>(s2)<br>s.c = <span class="hljs-number">10</span><br>s.a = <span class="hljs-number">20</span><br>s.s1.b = <span class="hljs-number">30</span> <span class="hljs-comment">//当名字有冲突时只能这样，无冲突时与s.b结果一样</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;结构体&quot;&gt;结构体&lt;/h1&gt;
&lt;p&gt;定义格式：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    <category term="Go" scheme="https://nothingalr8.top/categories/Go/"/>
    
    <category term="从零开始的Go" scheme="https://nothingalr8.top/categories/Go/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go/"/>
    
    
    <category term="Go" scheme="https://nothingalr8.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的Go(9)-Map</title>
    <link href="https://nothingalr8.top/2022/10/28/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go(9)-Map/"/>
    <id>https://nothingalr8.top/2022/10/28/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go(9)-Map/</id>
    <published>2022-10-28T13:35:23.000Z</published>
    <updated>2022-11-22T10:58:05.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义">定义</h1><p>可以使用<code>map()</code>来声明一个<code>map</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> identifier <span class="hljs-keyword">map</span>[keytype]valuetype<span class="hljs-comment">//只是声明了一个map，但是没有分配内存，不能用来存放键值。</span><br></code></pre></td></tr></table></figure><p>一个<code>map</code>是无序的键值对的集合，类似与<code>python</code>中的<code>dictionary</code>，可以动态增加，未初始化的<code>map</code>值为<code>nil</code>。</p><p>在<code>map</code>中，<code>key</code>可以为<code>float</code>、<code>int</code>、<code>string</code>等类型，但不能为切片与结构体(含有数组切片的结构体不能作为<code>key</code>，只包含内建类型的 <code>struct</code> 是可以作为<code>key</code> 的)，可以为指针与接口。</p><p>而<code>value</code>可以为任意类型(但是使用空接口时，需要先做一次类型断言)。</p><p>使用<code>len()</code>可以获取<code>map</code>中键值对的数量。</p><h1 id="初始化">初始化</h1><p>在<code>go</code>中，<code>map</code>是引用类型，未初始化的值为<code>nil</code>，使用以下方式来初始化<code>map</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> map1 <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span> <br>map1 = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br><br><span class="hljs-keyword">var</span> map2 <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span><br>map2 = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;key1&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;key2&quot;</span>:<span class="hljs-string">&quot;2&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>也可以将声明与初始化写在一起：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">map1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<span class="hljs-comment">//声明+分配内存</span><br>map2 := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;key1&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;key2&quot;</span>:<span class="hljs-string">&quot;2&quot;</span>&#125;<span class="hljs-comment">//声明+初始化</span><br></code></pre></td></tr></table></figure><h1 id="使用">使用</h1><h2 id="添加元素">添加元素</h2><p>格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">identifier [newkey] = value<span class="hljs-comment">//需要先初始化</span><br></code></pre></td></tr></table></figure><h2 id="删除元素">删除元素</h2><p>使用<code>delete()</code>函数来删除<code>map</code>中的元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">delete</span>(identifier, <span class="hljs-string">&quot;key&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="获取key对应的value">获取key对应的value</h2><p>格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">a,b = identifier[key]<span class="hljs-comment">//将map identifier的key值对应的value赋给变量a</span><br><span class="hljs-comment">// b将返回一个布尔值，若key存在则为true，反之则为false，若不需要判断，可以省略</span><br></code></pre></td></tr></table></figure><h2 id="for-range的使用">for-range的使用</h2><p>格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> map1 &#123;<br>fmt.Printf(<span class="hljs-string">&quot;key is: %d\n&quot;</span>, key)<br>&#125;<br></code></pre></td></tr></table></figure><p>第一个返回值<code>key</code>为<code>map</code>的键值，第二个返回值<code>value</code>为键值对应的值。但是，<code>map</code>是一个无序集合，所以返回的<code>key</code>的顺序并无法确定。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;定义&quot;&gt;定义&lt;/h1&gt;
&lt;p&gt;可以使用&lt;code&gt;map()&lt;/code&gt;来声明一个&lt;code&gt;map&lt;/code&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;spa</summary>
      
    
    
    
    <category term="Go" scheme="https://nothingalr8.top/categories/Go/"/>
    
    <category term="从零开始的Go" scheme="https://nothingalr8.top/categories/Go/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go/"/>
    
    
    <category term="Go" scheme="https://nothingalr8.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的Go(8)-指针</title>
    <link href="https://nothingalr8.top/2022/10/28/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go(8)-%E6%8C%87%E9%92%88/"/>
    <id>https://nothingalr8.top/2022/10/28/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go(8)-%E6%8C%87%E9%92%88/</id>
    <published>2022-10-28T09:35:23.000Z</published>
    <updated>2022-11-22T10:58:02.211Z</updated>
    
    <content type="html"><![CDATA[<p>在程序运行时，使用到的变量值被存储在内存中，而每个内存块都有一个地址，当程序使用变量时，实际上就是在内存中使用一个地址中的值。</p><p>在Go中，取地址符为<code>&amp;</code>，可以用与获取一个变量的地址。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span><br>fmt.Printf(<span class="hljs-string">&quot;%d&quot;</span>,i)<span class="hljs-comment">//输出i的值</span><br>fmt.Printf(<span class="hljs-string">&quot;%p&quot;</span>,&amp;i)<span class="hljs-comment">//输出i的内存地址</span><br></code></pre></td></tr></table></figure><h1 id="指针变量">指针变量</h1><p>指针是指向了一个值的内存地址的变量。</p><p>声明格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> identifier *<span class="hljs-keyword">type</span><br></code></pre></td></tr></table></figure><p><code>identifier</code>：定义的指针的名称</p><p><code>type</code>：指针类型，即指向的值的类型</p><p>当一个指针被定义但没有分配到变量时，其默认值为<code>nil</code>。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ptr *<span class="hljs-type">int</span><br>i := <span class="hljs-number">1</span><br>ptr = &amp;i<span class="hljs-comment">//为指针赋值</span><br>fmt.Printf(<span class="hljs-string">&quot;%p\n&quot;</span>,ptr)<br></code></pre></td></tr></table></figure><p><code>*</code>可以作为类型转换器，用于获取指针指向内容的值(不同于类型定义中的<code>*</code>)</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ptr *<span class="hljs-type">int</span><br>i := <span class="hljs-number">1</span><br>ptr = &amp;i<br>fmt.Println(*ptr)<span class="hljs-comment">//结果为1</span><br></code></pre></td></tr></table></figure><h1 id="指针的使用">指针的使用</h1><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ptr *<span class="hljs-type">int</span><br>i := <span class="hljs-number">1</span><br>ptr = &amp;i<br>*ptr = <span class="hljs-number">2</span> <br>fmt.Println(*ptr)<span class="hljs-comment">//结果为2</span><br>fmt.Println(i)<span class="hljs-comment">//结果为2</span><br></code></pre></td></tr></table></figure><p>通过示例可以发现，通过对<code>*ptr</code>的赋值，也同时改变了变量<code>i</code>的值。</p><p>注意，Go中不能对指针进行运算。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在程序运行时，使用到的变量值被存储在内存中，而每个内存块都有一个地址，当程序使用变量时，实际上就是在内存中使用一个地址中的值。&lt;/p&gt;
&lt;p&gt;在Go中，取地址符为&lt;code&gt;&amp;amp;&lt;/code&gt;，可以用与获取一个变量的地址。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;figure</summary>
      
    
    
    
    <category term="Go" scheme="https://nothingalr8.top/categories/Go/"/>
    
    <category term="从零开始的Go" scheme="https://nothingalr8.top/categories/Go/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go/"/>
    
    
    <category term="Go" scheme="https://nothingalr8.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的Go(7)-数组与切片</title>
    <link href="https://nothingalr8.top/2022/10/24/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go(7)-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/"/>
    <id>https://nothingalr8.top/2022/10/24/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go(7)-%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87/</id>
    <published>2022-10-24T09:35:23.000Z</published>
    <updated>2022-11-22T10:57:59.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组">数组</h1><p>数组是具有相同<strong>唯一类型</strong>的一组以<strong>编号且长度固定</strong>的数据项序列，是一种基本类型。</p><h2 id="定义">定义</h2><p>定义格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> identifier [<span class="hljs-built_in">len</span>]<span class="hljs-keyword">type</span><br></code></pre></td></tr></table></figure><p><code>indentifier</code>：数组名</p><p><code>type</code>：数组类型，可以为整形、浮点型、字符型、字符串等</p><p><code>len</code>：数组的长度。</p><p>也所以可以通过 <code>new()</code> 来创建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> identifier = <span class="hljs-built_in">new</span>([<span class="hljs-built_in">len</span>]<span class="hljs-keyword">type</span>)<br>identifier := <span class="hljs-built_in">new</span>([<span class="hljs-built_in">len</span>]<span class="hljs-keyword">type</span>)<br></code></pre></td></tr></table></figure><p>数组第一个元素的索引为0，最后一个元素的索引为<code>len-1</code>。</p><p>Go 语言中的数组是一种<strong>值类型</strong>（不像 C/C++中是指向首元素的指针)。</p><h2 id="赋值">赋值</h2><p>通过以下几种方法对数组进行赋值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">arr1[i] = value<span class="hljs-comment">//对数组的单个元素赋值</span><br><span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">18</span>, <span class="hljs-number">20</span>, <span class="hljs-number">15</span>, <span class="hljs-number">22</span>, <span class="hljs-number">16</span>&#125; <span class="hljs-comment">//在定义时同时赋值</span><br><span class="hljs-keyword">var</span> arr3 = [<span class="hljs-number">5</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">18</span>, <span class="hljs-number">20</span>&#125;<span class="hljs-comment">//a[0]=18,a[1]=20,后面被赋值为0</span><br><span class="hljs-keyword">var</span> arrKeyValue = [<span class="hljs-number">5</span>]<span class="hljs-type">string</span>&#123;<span class="hljs-number">3</span>: <span class="hljs-string">&quot;Chris&quot;</span>, <span class="hljs-number">4</span>: <span class="hljs-string">&quot;Ron&quot;</span>&#125;<span class="hljs-comment">//赋值了a[3]与a[4]</span><br></code></pre></td></tr></table></figure><h1 id="切片">切片</h1><h2 id="定义-1">定义</h2><p>切片(slice)是对数组一个连续片段的引用，但和数组不同，切片的长度可以在运行过程中被修改，是引用类型。</p><p>定义格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> identifier []<span class="hljs-keyword">type</span><span class="hljs-comment">//[]中不需要加长度</span><br></code></pre></td></tr></table></figure><p>在默认状况下，未进行初始化与赋值的切片长度为0，默认为nil。</p><p>也可以通过make()来创建切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">identifier := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">type</span>, <span class="hljs-built_in">len</span>, capacity)<span class="hljs-comment">//其中capacity部分可省略</span><br><span class="hljs-keyword">var</span> identifier <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">type</span>, <span class="hljs-built_in">len</span>)<br></code></pre></td></tr></table></figure><p>其中，<code>len</code>为切片初始长度，<code>capacity</code>为切片容量。</p><h2 id="初始化与赋值">初始化与赋值</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><br></code></pre></td></tr></table></figure><p>​</p><h2 id="长度与容量">长度与容量</h2><h2 id="section"></h2><h1 id="for-range的使用">for-range的使用</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数组&quot;&gt;数组&lt;/h1&gt;
&lt;p&gt;数组是具有相同&lt;strong&gt;唯一类型&lt;/strong&gt;的一组以&lt;strong&gt;编号且长度固定&lt;/strong&gt;的数据项序列，是一种基本类型。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;定义&lt;/h2&gt;
&lt;p&gt;定义格式：&lt;/p&gt;
&lt;figure </summary>
      
    
    
    
    <category term="Go" scheme="https://nothingalr8.top/categories/Go/"/>
    
    <category term="从零开始的Go" scheme="https://nothingalr8.top/categories/Go/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go/"/>
    
    
    <category term="Go" scheme="https://nothingalr8.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的Go(6)-控制结构</title>
    <link href="https://nothingalr8.top/2022/10/22/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go(6)-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"/>
    <id>https://nothingalr8.top/2022/10/22/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go(6)-%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</id>
    <published>2022-10-22T09:35:23.000Z</published>
    <updated>2022-11-22T10:57:56.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分支结构">分支结构</h1><h2 id="if-else结构">if-else结构</h2><p><code>if</code>是用于测试某个条件（布尔型或逻辑型）的语句，如果该条件成立，则会执行<code>if</code>后由大括号括起来的代码块，否则就忽略该代码块继续执行后续的代码。如果忽略了，若存在<code>else</code>分支，则执行<code>else</code>后由大括号括起来的代码块。</p><p>注意：与C语言不同，即使<code>if</code>之后只有一条需要执行的代码，也需要用大括号括起来。同时，<code>if</code>的右大括号需要与<code>else</code>在同一行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> condition &#123;<br>    <span class="hljs-comment">// do something </span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> condition &#123;<br>    <span class="hljs-comment">// do something </span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// do something </span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>当然也可以在<code>else</code>后面添加<code>if</code>，来进行多分支判断。其中，<code>else-if</code>分支没有数量限制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> condition1 &#123;<br>    <span class="hljs-comment">// do something </span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> condition2 &#123;<br>    <span class="hljs-comment">// do something else    </span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// catch-all or default</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同时，<code>if</code>语句也可对数值进行初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> initialization; condition &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"> <span class="hljs-keyword">if</span> val := <span class="hljs-number">10</span>; val &gt; max &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><p>值得注意的是，如果<code>if</code>结构内有<code>break</code>、<code>continue</code>、<code>goto</code> 或者<code>return</code> 语句时，一般省略 <code>else</code> 部分。</p><p>如，无论满足哪个条件都会返回 <code>x</code> 或者 <code>y</code>时，一般使用以下写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> condition &#123;<br>    <span class="hljs-keyword">return</span> x<br>&#125;<br><span class="hljs-keyword">return</span> y<br></code></pre></td></tr></table></figure><p>同时在 <code>if-else</code> 结构的两个分支里都使用 return语句，这将导致编译报错。</p><h2 id="switch结构">switch结构</h2><p>Go中<code>switch</code>是一个非常灵活的结构，它可以接受任何形式的表达式。</p><p>每一个<code>case</code>都是唯一的，从上到下逐一测试，直到匹配的<code>case</code>或是<code>default</code>，然后执行语句，<code>case</code>后面也不需要加大括号。</p><p>注意：go的<code>switch</code>在执行完<code>case</code>的语句后会直接退出，不需要额外加<code>break</code>。如果在执行完每个分支的代码后，还希望继续执行后续分支的代码，可以使用<code>fallthrough</code>关键字来达到目的。</p><p>switch后面可以跟着一个变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> var1 &#123;<br>    <span class="hljs-keyword">case</span> val1:<br>        <span class="hljs-comment">// do something</span><br>    <span class="hljs-keyword">case</span> val2:<br>        <span class="hljs-comment">// do something</span><br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><p>也可以这样使用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> &#123;<br>    <span class="hljs-keyword">case</span> condition1:<br>        <span class="hljs-comment">// do something</span><br>    <span class="hljs-keyword">case</span> condition2:<br>        <span class="hljs-comment">// do something</span><br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这种使用方式非常像多重<code>if-else</code>结构，但看上去更简洁，可读性更高。</p><p>switch语句也可以加上初始化语句(参考<code>if-else</code>的初始化)：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> initialization &#123;<br>    <span class="hljs-keyword">case</span> condition1:<br>        <span class="hljs-comment">// do something</span><br>    <span class="hljs-keyword">case</span> condition2:<br>        <span class="hljs-comment">// do something</span><br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="循环结构">循环结构</h1><h2 id="for语句">for语句</h2><p>在go中，没有while，只有for循环，但是for可以替代while使用。</p><h3 id="基于计数器的迭代">基于计数器的迭代</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> initialization; codition; post &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>initialization</code>：初始化赋值语句，只执行一次</p></li><li><p><code>condition</code>：循环控制条件，每次循环开始先判断</p></li><li><p><code>post</code>：控制循环变量，每次循环结束执行一次</p></li></ul><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;This is the %d iteration\n&quot;</span>, i)<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果</span><br><span class="hljs-comment">This is the 0 iteration</span><br><span class="hljs-comment">This is the 1 iteration</span><br><span class="hljs-comment">This is the 2 iteration</span><br><span class="hljs-comment">This is the 3 iteration</span><br><span class="hljs-comment">This is the 4 iteration</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="基于条件判断的迭代">基于条件判断的迭代</h3><p>这种循环类似其他语言中的while循环。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> conditon &#123;<br><span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go">i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i &lt;= <span class="hljs-number">5</span>&#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%d&quot;</span>,i)<br>    i++<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果</span><br><span class="hljs-comment">0</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">4</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="for-range结构">for-range结构</h3><p>在go中，可以使用<code>for-range</code>结构来迭代任意一个集合(包括数组和map)，一般的结构为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> index, val := <span class="hljs-keyword">range</span> coll &#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>使用这种结构可以得到每次迭代对应的索引<code>index</code>和值<code>val</code>。</p><p>同时，字符串也可以进行迭代，来获取每个字节的索引(位置)与值。</p><h2 id="break和continue">break和continue</h2><p><code>break</code>可以被用于任何一种<code>for</code>语句中，用于退出循环，但是只会退出一层循环。</p><p><code>continue</code>只能被用于循环中，用于结束这一次循环，接着进行循环条件判断，进入下一次循环。</p><h1 id="标签与goto">标签与goto</h1><p>for、switch 或 select语句都可以配合标签（label）形式的标识符使用，即某一行第一个以冒号结尾的单词。</p><p>（标签的名称是大小写敏感的，为了提升可读性，一般建议使用全部大写字母）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-number">1</span><br><span class="hljs-keyword">goto</span> LABEL1<br>LABEL1:<br>a = <span class="hljs-number">10</span><br>fmt.Println(a)<br></code></pre></td></tr></table></figure><p>注意：标签与<code>goto</code>的使用非常有可能会导致意大利面条式代码，这会使代码变得非常糟糕，尽量减少使用或不使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分支结构&quot;&gt;分支结构&lt;/h1&gt;
&lt;h2 id=&quot;if-else结构&quot;&gt;if-else结构&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;if&lt;/code&gt;
是用于测试某个条件（布尔型或逻辑型）的语句，如果该条件成立，则会执行
&lt;code&gt;if&lt;/code&gt;
后由大括号括起来的代码块</summary>
      
    
    
    
    <category term="Go" scheme="https://nothingalr8.top/categories/Go/"/>
    
    <category term="从零开始的Go" scheme="https://nothingalr8.top/categories/Go/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go/"/>
    
    
    <category term="Go" scheme="https://nothingalr8.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的Go(5)-字符串</title>
    <link href="https://nothingalr8.top/2022/10/19/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go(5)-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://nothingalr8.top/2022/10/19/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go(5)-%E5%AD%97%E7%AC%A6%E4%B8%B2/</id>
    <published>2022-10-19T09:35:23.000Z</published>
    <updated>2022-11-22T10:57:52.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串">字符串</h1><p>在Go中，字符串是 <code>UTF-8</code>字符的一个序列，一个字符可能占用1个字节(ASCII码)，或是2~4个字节。</p><h2 id="定义">定义</h2><p>通过以下两种形式定义字符串：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s1 <span class="hljs-type">string</span><br>s2 := <span class="hljs-string">&quot;Hello!&quot;</span><br></code></pre></td></tr></table></figure><h2 id="索引与切片">索引与切片</h2><h3 id="索引">索引</h3><p>可以将一个字符串看成数组，来获取其某一字节上的值。类似数组，string[0]对应第一个字节。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := <span class="hljs-string">&quot;hello&quot;</span><br>fmt.Println(s1[<span class="hljs-number">0</span>])<span class="hljs-comment">//结果为104，对于h的ASCII码</span><br>fmt.Println(s1[<span class="hljs-number">3</span>])<span class="hljs-comment">//结果为108，对于l的ASCII码</span><br>fmt.Println(<span class="hljs-type">string</span>(s1[<span class="hljs-number">3</span>]))<span class="hljs-comment">//加上string()函数,则输出字符</span><br></code></pre></td></tr></table></figure><p>而对于中文等多字节字符，并不可以直接使用索引来得出各位字符，只能得到某个字节的值，需要先转换为rune切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">s2 := <span class="hljs-string">&quot;你好！&quot;</span><br>fmt.Println(([]<span class="hljs-type">rune</span>(s2))[<span class="hljs-number">0</span>])<span class="hljs-comment">//结果为20320，为4f60的十进制表示形式，为&#x27;你&#x27;的UTF-8编码</span><br>fmt.Println(<span class="hljs-type">string</span>(([]<span class="hljs-type">rune</span>(s2))[<span class="hljs-number">0</span>]))<span class="hljs-comment">//结果为&quot;你&quot;</span><br></code></pre></td></tr></table></figure><h3 id="切片">切片</h3><p>通过以下方式来获取字符串的某几个连续字节上的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := <span class="hljs-string">&quot;hello!&quot;</span><br>fmt.Println(s1[<span class="hljs-number">0</span>:<span class="hljs-number">5</span>])<span class="hljs-comment">// &quot;hello&quot;遵循向前取整的规则，取到索引为4的字节</span><br>fmt.Println(s1[:<span class="hljs-number">5</span>])<span class="hljs-comment">// &quot;hello&quot;前一个数为空，即从0开始</span><br>fmt.Println(s1[<span class="hljs-number">4</span>:])<span class="hljs-comment">// &quot;o!&quot;后一个数为空，即到最后一个字符为止</span><br>fmt.Println(s1[:]) <span class="hljs-comment">// &quot;hello!&quot;若两个字符都为空，则取整个字符串</span><br></code></pre></td></tr></table></figure><p>同样的，对与中文字符，需要先转化为<code>rune</code>切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">s2 := <span class="hljs-string">&quot;你好！&quot;</span><br>fmt.Println(([]<span class="hljs-type">rune</span>(s2))[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>])<span class="hljs-comment">//结果为[20320 22909]，为&#x27;你&#x27;与&#x27;好&#x27;的UTF-8编码</span><br>fmt.Println(<span class="hljs-type">string</span>(([]<span class="hljs-type">rune</span>(s2))[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]))<span class="hljs-comment">//加上string()函数，则输出&quot;你好&quot;</span><br></code></pre></td></tr></table></figure><h2 id="编辑">编辑</h2><p>在Go中，无法直接对string的某一位上的值进行改变，需要先进行类型的转化。</p><p>运行以下命令会出错：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := <span class="hljs-string">&quot;hello!&quot;</span><br>s1[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;1&#x27;</span><br></code></pre></td></tr></table></figure><p>如果是单一的ASCII码组成的字符串，则可以转化成<code>[]byte</code>类型，而含有多字节字符的则需转化位<code>[]rune</code>类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := <span class="hljs-string">&quot;hello!&quot;</span><br>s1_ := []<span class="hljs-type">byte</span>(s1)<span class="hljs-comment">//转化成[]byte类型</span><br>s1_[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;H&#x27;</span><br>fmt.Println(<span class="hljs-type">string</span>(s1_))<span class="hljs-comment">//结果为&quot;Hello!&quot;</span><br><br>s2 := <span class="hljs-string">&quot;你好！&quot;</span><br>s2_ := []<span class="hljs-type">rune</span>(s2)<span class="hljs-comment">//转化成[]rune类型</span><br>s2_[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;您&quot;</span><br>fmt.Println(<span class="hljs-type">string</span>(s2_))<span class="hljs-comment">//结果为&quot;您好！&quot;</span><br></code></pre></td></tr></table></figure><h2 id="拼接与比较">拼接与比较</h2><h3 id="拼接">拼接</h3><p>使用<code>+</code>对字符串进行拼接（当然可以使用<code>+=</code>），如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := <span class="hljs-string">&quot;Hello &quot;</span><br>s2 := <span class="hljs-string">&quot;World!&quot;</span><br>s3 := s1+s2<span class="hljs-comment">//s3结果为&quot;Hello World!&quot;</span><br></code></pre></td></tr></table></figure><h3 id="比较">比较</h3><p>字符串的比较是按字节比较，从第一个字节开始比较，大的为字符串的第一个字节大的字符串，如果第一个字节一样大，则顺次比较。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := <span class="hljs-string">&quot;ab&quot;</span><br>s2 := <span class="hljs-string">&quot;123&quot;</span><br>fmt.Println(s1 &gt; s2) <span class="hljs-comment">//结果为true</span><br></code></pre></td></tr></table></figure><h2 id="求长度">求长度</h2><p>可以通过<code>len()</code>函数来获取字符串的长度，但是这个函数实际上求的是字符串的字节长度。</p><p>可以通过以下代码来看出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := <span class="hljs-string">&quot;Hello!&quot;</span><br>fmt.Println(<span class="hljs-built_in">len</span>(s1))<span class="hljs-comment">//得出的结果为6，一个ASCII字符占1个字节</span><br><br>s2 :=  <span class="hljs-string">&quot;你好！&quot;</span><br>fmt.Println(<span class="hljs-built_in">len</span>(s2))<span class="hljs-comment">//得出的结果为9，在UTF-8中，每一个中文及全角字符占3个字节</span><br></code></pre></td></tr></table></figure><p>那要如何计算出除ASCII码之外字符的实际长度呢？也需转化为rune切片：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s2 :=  <span class="hljs-string">&quot;你好！&quot;</span><br>fmt.Println(<span class="hljs-built_in">len</span>([]<span class="hljs-type">rune</span>(s2)))<span class="hljs-comment">//得出结果为3</span><br></code></pre></td></tr></table></figure><h1 id="相关包">相关包</h1><h2 id="strings包">strings包</h2><p>strings包为go提供了一系列对字符串进行操作的函数。</p><h3 id="前缀与后缀">前缀与后缀</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">strings.HasPrefix(s, prefix <span class="hljs-type">string</span>) <span class="hljs-type">bool</span><span class="hljs-comment">//判断前缀，若对与字符串s来说，前缀为prefix，则返回true，反之则返回false</span><br>strings.HasSuffix(s, suffix <span class="hljs-type">string</span>) <span class="hljs-type">bool</span><span class="hljs-comment">//判断后缀，同判断前缀</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := <span class="hljs-string">&quot;hello&quot;</span><br>fmt.Println(strings.HasPrefix(s1,<span class="hljs-string">&quot;h&quot;</span>))<span class="hljs-comment">//结果为true</span><br></code></pre></td></tr></table></figure><h3 id="包含">包含</h3><p><code>strings.Contains(s, substr string) bool</code></p><p>判断字符串<code>s</code>是否包含<code>substr</code>部分，若包含，返回true，反之则返回false</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := <span class="hljs-string">&quot;hello&quot;</span><br>fmt.Println(strings.Contains(s1,<span class="hljs-string">&quot;hell&quot;</span>))<span class="hljs-comment">//结果为true</span><br>fmt.Println(strings.Contains(s1,<span class="hljs-string">&quot;helll&quot;</span>))<span class="hljs-comment">//结果为false</span><br></code></pre></td></tr></table></figure><h3id="获取某字符串在另一字符串中位置索引">获取某字符串在另一字符串中位置(索引)</h3><p>返回为str在字符串s中的第一个索引位置，若str为字符串，则返回第一个字符对应的索引位置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">strings.Index(s, str <span class="hljs-type">string</span>) <span class="hljs-type">int</span><br>strings.LastIndex(s, str <span class="hljs-type">string</span>) <span class="hljs-type">int</span><span class="hljs-comment">//规则同Index，但是返回最后一个符合的索引位置</span><br>strings.IndexRune(s <span class="hljs-type">string</span>, r <span class="hljs-type">rune</span>) <span class="hljs-type">int</span><span class="hljs-comment">//适用于非ASCII字符串</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := <span class="hljs-string">&quot;hello&quot;</span><br>fmt.Println(strings.Index(s1, <span class="hljs-string">&quot;l&quot;</span>))<span class="hljs-comment">//结果为2</span><br>fmt.Println(strings.Index(s1, <span class="hljs-string">&quot;el&quot;</span>))<span class="hljs-comment">//结果为1</span><br>fmt.Println(strings.LastIndex(s1, <span class="hljs-string">&quot;l&quot;</span>))<span class="hljs-comment">//结果为3</span><br></code></pre></td></tr></table></figure><h3 id="出现次数统计">出现次数统计</h3><p><code>strings.Count(s, str string) int</code></p><p>统计<code>str</code>在字符串<code>s</code>中出现的次数，并返回。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := <span class="hljs-string">&quot;hello&quot;</span><br>fmt.Println(strings.Count(s1, <span class="hljs-string">&quot;l&quot;</span>))<span class="hljs-comment">//结果为2</span><br>fmt.Println(strings.Count(s1, <span class="hljs-string">&quot;e&quot;</span>))<span class="hljs-comment">//结果为1</span><br></code></pre></td></tr></table></figure><h3 id="重复字符串">重复字符串</h3><p>重复<code>count</code>次字符串<code>s</code>，并返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">strings.Repeat(s, count <span class="hljs-type">int</span>) <span class="hljs-type">string</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := <span class="hljs-string">&quot;hello &quot;</span><br>fmt.Println(strings.Repeat(s1, <span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure><h3 id="从字符串中读取内容">从字符串中读取内容</h3><p>函数 <code>strings.NewReader()</code> 用于生成一个<code>Reader</code> 并读取字符串中的内容，然后返回指向该<code>Reader</code> 的指针，从其它类型读取内容的函数还有：</p><p><code>Read()</code>从<code>[]byte</code>中读取内容。<code>ReadByte()</code> 和 <code>ReadRune()</code>从字符串中读取下一个<code>byte</code> 或者 <code>rune</code>。</p><h3 id="字符串替换">字符串替换</h3><p><code>strings.Replace(str, old, new string, n int) string</code></p><p>将字符串<code>str</code>中的前 <code>n</code>个字符串<code>old</code>替换为字符串<code>new</code>，并返回一个新的字符串。如果<code>n = -1</code>则替换所有字符串<code>old</code>为字符串<code>new</code></p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := <span class="hljs-string">&quot;hello&quot;</span><br>fmt.Println(strings.Replace(s1,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>,<span class="hljs-number">1</span>))<span class="hljs-comment">//heolo</span><br>fmt.Println(strings.Replace(s1,<span class="hljs-string">&quot;l&quot;</span>,<span class="hljs-string">&quot;o&quot;</span>,<span class="hljs-number">-1</span>))<span class="hljs-comment">//heooo</span><br></code></pre></td></tr></table></figure><h3 id="修剪字符串">修剪字符串</h3><p>使用 <code>strings.TrimSpace()</code>来剔除字符串开头和结尾的空白符号</p><p>如果想要剔除指定字符，则可以使用 <code>strings.Trim(s, "cut")</code>来将开头和结尾的 <code>cut</code> 部分去除掉</p><p>如果只想剔除开头或者结尾的字符串，则可以使用<code>strings.TrimLeft</code> 或者 <code>strings.TrimRight</code>来实现</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := <span class="hljs-string">&quot; hello &quot;</span><br>s2 := <span class="hljs-string">&quot;hellhe&quot;</span><br>fmt.Println(strings.TrimSpace(s1))<span class="hljs-comment">//hello</span><br>fmt.Println(strings.Trim(s2, <span class="hljs-string">&quot;he&quot;</span>))<span class="hljs-comment">//ll</span><br>fmt.Println(strings.TrimLeft(s2, <span class="hljs-string">&quot;he&quot;</span>))<span class="hljs-comment">//llhe</span><br>fmt.Println(strings.TrimRight(s2, <span class="hljs-string">&quot;he&quot;</span>))<span class="hljs-comment">//hell</span><br></code></pre></td></tr></table></figure><h3 id="大小写转换">大小写转换</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">strings.ToLower(s) <span class="hljs-type">string</span><span class="hljs-comment">//将字符串s中的所有大写字母转换为小写字母</span><br>strings.ToUpper(s) <span class="hljs-type">string</span><span class="hljs-comment">//将字符串s中的所有小写字母转换为大写字母</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := <span class="hljs-string">&quot;hello!&quot;</span><br>fmt.Println(strings.ToUpper(s1))<br>s2 := <span class="hljs-string">&quot;HeLLO!&quot;</span><br>fmt.Println(strings.ToLower(s2))<br></code></pre></td></tr></table></figure><h2 id="strconv包">strconv包</h2><p>strconv包为go提供了许多字符串与其他类型转换的函数。</p><h3 id="数字转换字符串">数字转换字符串</h3><p><code>strconv.Itoa(i int) string</code></p><p>返回数字 <code>i</code> 所表示的字符串类型的十进制数</p><p><code>strconv.FormatFloat(f float64, fmt byte, prec int, bitSize int) string</code></p><p>将 64 位浮点型的数字<code>f</code>转换为字符串并返回，其中<code>fmt</code> 表示格式（其值可以是 'b'、'e'、'f' 或'g'），<code>prec</code> 表示精度，<code>bitSize</code> 则使用 32 表示float32，用 64 表示 float64</p><h3 id="字符串转换数字">字符串转换数字</h3><h4 id="转换为整形">转换为整形</h4><p><code>strconv.Atoi(s string) (i int, err error)</code></p><p>将数字字符串<code>s</code>转化为整数<code>i</code>，并返回，如果产生错误，返回<code>err</code></p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := <span class="hljs-string">&quot;123&quot;</span><br>a, err := strconv.Atoi(s1) <br><span class="hljs-comment">// 若不需要返回错误，可以直接这样写：</span><br><span class="hljs-comment">//a, _ := strconv.Atoi(s1) </span><br>fmt.Println(a)<br>fmt.Println(err)<br></code></pre></td></tr></table></figure><h4 id="转换为浮点型">转换为浮点型</h4><p><code>strconv.ParseFloat(s string, bitSize int) (f float64, err error)</code></p><p>将数字字符串(可以含小数)<code>s</code>转换为浮点型<code>f</code>，如果产生错误，返回<code>err</code>，<code>bitSize</code>可以位32或64，表示float32或float64</p><h3 id="其他">其他</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">strconv.IntSize<span class="hljs-comment">//获取程序运行的操作系统平台下 int 类型所占的位数</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;字符串&quot;&gt;字符串&lt;/h1&gt;
&lt;p&gt;在Go中，字符串是 &lt;code&gt;UTF-8&lt;/code&gt;
字符的一个序列，一个字符可能占用1个字节(ASCII码)，或是2~4个字节。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;定义&lt;/h2&gt;
&lt;p&gt;通过以下两种形式定义字符串：&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Go" scheme="https://nothingalr8.top/categories/Go/"/>
    
    <category term="从零开始的Go" scheme="https://nothingalr8.top/categories/Go/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go/"/>
    
    
    <category term="Go" scheme="https://nothingalr8.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的Go(4)-运算</title>
    <link href="https://nothingalr8.top/2022/10/18/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go(4)-%E8%BF%90%E7%AE%97/"/>
    <id>https://nothingalr8.top/2022/10/18/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go(4)-%E8%BF%90%E7%AE%97/</id>
    <published>2022-10-18T05:35:23.000Z</published>
    <updated>2022-11-22T10:57:49.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本运算符">基本运算符</h1><h2 id="算数运算符">算数运算符</h2><table><thead><tr class="header"><th>运算符</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>+</td><td>加法运算</td></tr><tr class="even"><td>-</td><td>减法运算</td></tr><tr class="odd"><td>*</td><td>乘法运算</td></tr><tr class="even"><td>/</td><td>除法运算</td></tr><tr class="odd"><td>%</td><td>取余运算</td></tr><tr class="even"><td>++</td><td>自增运算</td></tr><tr class="odd"><td>--</td><td>自减运算</td></tr></tbody></table><p>其中除自增运算与自减运算为一元运算符，其余为二元运算符。</p><h2 id="关系运算符">关系运算符</h2><p>关系运算符都为二元运算符，用于比较两个值的大小，并返回一个布尔值。</p><table><thead><tr class="header"><th>运算符</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>==</td><td>等号</td></tr><tr class="even"><td>!=</td><td>不等号</td></tr><tr class="odd"><td>&gt;</td><td>大于号</td></tr><tr class="even"><td>&lt;</td><td>小于号</td></tr><tr class="odd"><td>&gt;=</td><td>大于等于号</td></tr><tr class="even"><td>&lt;=</td><td>小于等于号</td></tr></tbody></table><h2 id="逻辑运算符">逻辑运算符</h2><p>逻辑运算符的对象是布尔值，也可以是一个结果为布尔值的表达式。</p><table><thead><tr class="header"><th>运算符</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>!</td><td>非运算</td></tr><tr class="even"><td>&amp;&amp;</td><td>与运算</td></tr><tr class="odd"><td>||</td><td>或运算</td></tr></tbody></table><p>其中非运算为一元运算符，与运算与或运算为二元运算符。</p><h2 id="位运算符">位运算符</h2><table><thead><tr class="header"><th>运算符</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>&amp;</td><td>按位与</td></tr><tr class="even"><td>|</td><td>按位或</td></tr><tr class="odd"><td>^</td><td>按位异或、按位补足</td></tr><tr class="even"><td>&amp;^</td><td>按位清除</td></tr><tr class="odd"><td>~</td><td>按位取反</td></tr><tr class="even"><td>&lt;&lt;</td><td>位左移</td></tr><tr class="odd"><td>&gt;&gt;</td><td>位右移</td></tr></tbody></table><p>其中^可用作一元运算符或二元运算符。</p><h2 id="其他">其他</h2><p>Go语言中也支持<code>+=</code>、<code>-=</code>等运算。</p><h1 id="math包"><code>math</code>包</h1><p>在Go语言中，<code>math</code>包提供了一些基本的数学函数与常量。</p><h2 id="常量">常量</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">math.E= <span class="hljs-number">2.71828182845904523536028747135266249775724709369995957496696763</span><br>math.Pi  = <span class="hljs-number">3.14159265358979323846264338327950288419716939937510582097494459</span><br>math.Phi = <span class="hljs-number">1.61803398874989484820458683436563811772030917980576286213544862</span><br><br>math.Sqrt2   = <span class="hljs-number">1.41421356237309504880168872420969807856967187537694807317667974</span><br>math.SqrtE   = <span class="hljs-number">1.64872127070012814684865078781416357165377610071014801157507931</span><br>math.SqrtPi  = <span class="hljs-number">1.77245385090551602729816748334114518279754945612238712821380779</span><br>math.SqrtPhi = <span class="hljs-number">1.27201964951406896425242246173749149171560804184009624861664038</span><br><br>math.Ln2    = <span class="hljs-number">0.693147180559945309417232121458176568075500134360255254120680009</span><br>math.Log2E  = <span class="hljs-number">1</span> / Ln2<br>math.Ln10   = <span class="hljs-number">2.30258509299404568401799145468436420760110148862877297603332790</span><br>math.Log10E = <span class="hljs-number">1</span> / Ln10<br></code></pre></td></tr></table></figure><h2 id="函数">函数</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">math.Abs() <span class="hljs-regexp">//</span>绝对值<br>math.Ceil()<span class="hljs-regexp">//</span>向上取整<br>math.Floor()      <span class="hljs-regexp">//</span>向下取整<br>math.Mod()      <span class="hljs-regexp">//</span>取余数，同<span class="hljs-number">11</span>%<span class="hljs-number">3</span><br>math.Modf()      <span class="hljs-regexp">//</span>取整数，取小数<br>math.Pow()       <span class="hljs-regexp">//</span>x的y次方<br>math.Pow10()        <span class="hljs-regexp">//</span> <span class="hljs-number">10</span>的n次方<br>math.Sqrt()        <span class="hljs-regexp">//</span>开平方<br>math.Cbrt())        <span class="hljs-regexp">//</span>开立方<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本运算符&quot;&gt;基本运算符&lt;/h1&gt;
&lt;h2 id=&quot;算数运算符&quot;&gt;算数运算符&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&quot;header&quot;&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr </summary>
      
    
    
    
    <category term="Go" scheme="https://nothingalr8.top/categories/Go/"/>
    
    <category term="从零开始的Go" scheme="https://nothingalr8.top/categories/Go/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go/"/>
    
    
    <category term="Go" scheme="https://nothingalr8.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>博客日志(4)-评论改动&amp;代码高亮</title>
    <link href="https://nothingalr8.top/2022/10/16/%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%BF%97(4)-%E8%AF%84%E8%AE%BA%E6%94%B9%E5%8A%A8&amp;%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE/"/>
    <id>https://nothingalr8.top/2022/10/16/%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%BF%97(4)-%E8%AF%84%E8%AE%BA%E6%94%B9%E5%8A%A8&amp;%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE/</id>
    <published>2022-10-16T14:14:01.000Z</published>
    <updated>2022-11-22T10:57:31.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="评论改动">评论改动</h1><p>对Valine存在一些不满意，我最终选择更换它，使用twikoo。</p><p>这个评论系统，确实十分方便好用，算是我用过的最好用的了。</p><p>可以根据QQ号来自动导入QQ邮箱、昵称与头像，有方便的邮箱提醒功能，可以便利地查看评论，算是比较满意了。</p><h1 id="代码高亮显示">代码高亮显示</h1><p>对于我博客的代码块，存在着高亮显示出错的问题，更换一个高亮主题后，已解决。</p><h1 id="访问统计">访问统计</h1><p>我还使用LeanCloud为博客添加了访问人数与访问次数的统计，并在博客的页脚显示这些内容。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;评论改动&quot;&gt;评论改动&lt;/h1&gt;
&lt;p&gt;对Valine存在一些不满意，我最终选择更换它，使用twikoo。&lt;/p&gt;
&lt;p&gt;这个评论系统，确实十分方便好用，算是我用过的最好用的了。&lt;/p&gt;
&lt;p&gt;可以根据QQ号来自动导入QQ邮箱、昵称与头像，有方便的邮箱提醒功能，可以</summary>
      
    
    
    
    <category term="博客日志" scheme="https://nothingalr8.top/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="博客日志" scheme="https://nothingalr8.top/tags/%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%BF%97/"/>
    
    <category term="hexo" scheme="https://nothingalr8.top/tags/hexo/"/>
    
    <category term="网站搭建" scheme="https://nothingalr8.top/tags/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的Go(3)-基本数据类型</title>
    <link href="https://nothingalr8.top/2022/10/16/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go(3)-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://nothingalr8.top/2022/10/16/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go(3)-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-10-16T05:35:23.000Z</published>
    <updated>2022-11-22T10:57:45.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常量与变量">常量与变量</h1><h2 id="常量">常量</h2><h3 id="定义">定义</h3><p>使用<code>const</code>关键字来定义常量，用以存储不会改变的布尔型、整数、浮点数、字符串或是复数。</p><p>定义格式 ：<code>const identifier [type] = value</code></p><p>如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> Pi = <span class="hljs-number">3.14</span><br></code></pre></td></tr></table></figure><p>其中<code>[type]</code>部分可以省略，编译器会自动识别其类型。</p><p>而<code>[value]</code>部分可以为表达式或无视精度限制(但在赋值给精度较小的变量时会错误发生或精度损失)。</p><p><code>[value]</code>部分不可以为自定义函数，但可以为内置函数，如<code>len()</code>。</p><h3 id="特殊常量值iota与枚举用法">特殊常量值iota与枚举用法</h3><p><code>iota</code>是go语言中的一个特殊常量值，只能被用于常量的赋值中。</p><p>在每一个<code>const</code>关键字出现时，<code>iota</code>就会被重置为0，然后每出现一个常量，<code>iota</code>所代表的数值会自动增加1。</p><p><code>iota</code>可以被用作枚举值，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    Female = <span class="hljs-literal">iota</span><br>    Male = <span class="hljs-literal">iota</span><br>    Unknown = <span class="hljs-literal">iota</span><br>)<br></code></pre></td></tr></table></figure><p>其运行后，Female = 0，Male = 1，Unknown = 2。与以下代码效果类似：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    Female = <span class="hljs-number">0</span><br>    Male = <span class="hljs-number">1</span><br>    Unknown = <span class="hljs-number">2</span><br>)<br></code></pre></td></tr></table></figure><p>而这也可以简写成下面这种形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    Female = <span class="hljs-literal">iota</span><br>    Male <br>    Unknown<br>)<br></code></pre></td></tr></table></figure><p><code>iota</code>也可以被用在表达式中，如：<code>iota + 10</code></p><h2 id="变量">变量</h2><h3 id="定义-1">定义</h3><p>使用<code>var</code>关键字来定义常量。</p><p>定义格式：</p><ol type="1"><li><code>var identifier [type]</code></li><li><code>var identifier [type] = [value]</code></li><li><code>identifier := [value]</code></li></ol><p>其中<code>[type]</code>部分一样可以省略，会由编译器来自动识，不过这不是所有时候都适用的。</p><p>当一个变量被声明之后，会被自动赋予一个默认值：<code>int</code>为0，<code>float</code>为0.0，<code>bool</code>为false，<code>string</code>为空字符串，指针为nil。</p><p>注意：若一个变量被定义后却未被使用会导致运行报错。</p><h3 id="只写变量_">只写变量_</h3><p><code>_</code>作为go中的一个只写变量，即只能对其赋值，而不能读取它的值，可以用它来舍弃一些不需要的值。如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">_,b = <span class="hljs-number">5</span>, <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>最终5的值被抛弃了。</p><h1 id="数据类型">数据类型</h1><h2 id="布尔型">布尔型</h2><p><code>bool</code>，用于存储true或false。</p><h2 id="整数型">整数型</h2><p>Go中的整数型分为<code>int</code>，<code>int8</code>，<code>int16</code>，<code>int32</code>，<code>int64</code>，<code>uint</code>，<code>uint8</code>，<code>uint16</code>，<code>uint32</code>，<code>uint64</code>，<code>rune</code>，<code>byte</code>。</p><p>其中，<code>int</code> 和 <code>uint</code>一般为32位，而<code>int8</code>，<code>int16</code>等的位数取决于变量类型最后的数字。</p><p>虽然<code>int</code>与<code>int32</code>在一般状况下大小相同，但是进行数据传递时一样需要类型转换，<code>uint</code>与<code>uint32</code>同理。</p><p>同时，Go中还有两种特殊的整数类型：</p><ul><li><code>rune</code> ：与 <code>int32</code>等价，代表了一个Unicode码点。</li><li><code>byte</code> ：与 <code>uint8</code>等价，代表了ASCII码的一个字符。</li></ul><h2 id="浮点型">浮点型</h2><p>Go中的整数型分为<code>float32</code>和<code>float64</code>两种，其位数与整数型命名规则相同。</p><p><code>float32</code>精确到小数点后7位，<code>float64</code>精确到小数点后15位。</p><p>应该尽可能地使用<code>float64</code>，因为<code>math</code>包中所有有关数学运算的函数都会要求接收这个类型。</p><h2 id="复数型">复数型</h2><p>在Go中用<code>complex64</code>来表示32位实数和虚数，用<code>complex128</code>来表示64位实数和虚数。</p><p>一个复数使用<code>re+imI</code>来表示，其中<code>re</code>代表实数部分，<code>im</code>代表虚数部分，、I`代表根号负1，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> c1 <span class="hljs-type">complex64</span> = <span class="hljs-number">5</span> + <span class="hljs-number">10i</span><br></code></pre></td></tr></table></figure><p>函数<code>real(c)</code>和<code>imag(c)</code>可以分别获得相应的实数和虚数部分。</p><h2 id="字符型">字符型</h2><p>严格来说，Go语言中没有字符类型，只是一种特殊的整数类型。</p><h3 id="byte">byte</h3><p><code>byte</code>类型是<code>uint8</code>的别称，可以表示单个ASCII字符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ch <span class="hljs-type">byte</span> = <span class="hljs-string">&#x27;A&#x27;</span><span class="hljs-comment">//直接通过字符赋值</span><br><span class="hljs-keyword">var</span> ch <span class="hljs-type">byte</span> = <span class="hljs-number">65</span> <span class="hljs-comment">//通过十进制ASCII码赋值</span><br><span class="hljs-keyword">var</span> ch <span class="hljs-type">byte</span> = <span class="hljs-string">&#x27;\x41&#x27;</span><span class="hljs-comment">//通过十六进制ASCII码赋值</span><br></code></pre></td></tr></table></figure><h3 id="rune">rune</h3><p><code>rune</code>类型是<code>int32</code>的别称，用于表示单个Unicode(UTF-8)字符。</p><p>在书写 Unicode字符时，需要在16进制数之前加上前缀<code>\u</code>或者<code>\U</code>。<code>\u</code>前缀跟着4位十六进制表示2个字节的Unicode字符，而<code>\U</code>前缀跟着8位十六进制表示2个字节以上的Unicode字符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ch <span class="hljs-type">rune</span> = <span class="hljs-string">&#x27;\u0041&#x27;</span><br><span class="hljs-keyword">var</span> ch2 <span class="hljs-type">rune</span> = <span class="hljs-string">&#x27;\u03B2&#x27;</span><br><span class="hljs-keyword">var</span> ch3 <span class="hljs-type">rune</span> = <span class="hljs-string">&#x27;\U00101234&#x27;</span><br></code></pre></td></tr></table></figure><p>包<code>unicode</code>包含了一些针对测试字符的非常有用的函数，如：</p><ul><li>判断是否为字母：<code>unicode.IsLetter(ch)</code></li><li>判断是否为数字：<code>unicode.IsDigit(ch)</code></li><li>判断是否为空白符号：<code>unicode.IsSpace(ch)</code></li></ul><p>其中<code>ch</code>代表字符，这些函数返回一个布尔值。</p><h2 id="类型别名">类型别名</h2><p>在使用某个类型时，可以使用<code>type</code>关键字给它起另一个名字，用于简化名称或解决名称冲突。</p><p>格式： <code>type [newname] [type]</code></p><p>如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TZ <span class="hljs-type">int</span><span class="hljs-comment">//TZ就是int的新名称</span><br><span class="hljs-keyword">var</span> a TZ<span class="hljs-comment">//定义a变量为TZ类型，即为int类型</span><br></code></pre></td></tr></table></figure><p>但实际上，类型别名得到的新类型并非和原类型完全相同，新类型不会拥有原类型所附带的方法。</p><h2 id="类型转换">类型转换</h2><p>格式：<code>valueOfTypeB = typeB(valueOfTypeA)</code></p><p>如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">int16</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">int</span> = <span class="hljs-number">10</span><br>a = <span class="hljs-type">int16</span>(b)<br></code></pre></td></tr></table></figure><p>注意：类型转换只能在定义正确的情况下转换成功，例如从一个取值范围较小的类型转换到一个取值范围较大的类型（将<code>int16</code> 转换为<code>int32</code>）。当从一个取值范围较大的类型转换到取值范围较小的类型时（将<code>int32</code> 转换为 <code>int16</code> 或将 <code>float32</code>转换为 <code>int</code>），会发生精度丢失（截断）的情况。</p><p>只有相同底层类型的变量之间可以进行相互转换（如将<code>int16</code>类型转换成<code>int32</code>类型），不同底层类型的变量相互转换时会引发编译错误（如将<code>bool</code>类型转换为<code>int</code>类型）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常量与变量&quot;&gt;常量与变量&lt;/h1&gt;
&lt;h2 id=&quot;常量&quot;&gt;常量&lt;/h2&gt;
&lt;h3 id=&quot;定义&quot;&gt;定义&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;const&lt;/code&gt;关键字来定义常量，用以存储不会改变的布尔型、整数、浮点数、字符串或是复数。&lt;/p&gt;
&lt;p&gt;定义格式 ：</summary>
      
    
    
    
    <category term="Go" scheme="https://nothingalr8.top/categories/Go/"/>
    
    <category term="从零开始的Go" scheme="https://nothingalr8.top/categories/Go/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go/"/>
    
    
    <category term="Go" scheme="https://nothingalr8.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的Go(2)-基本结构与命名规则</title>
    <link href="https://nothingalr8.top/2022/10/15/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go(2)-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E4%B8%8E%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/"/>
    <id>https://nothingalr8.top/2022/10/15/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go(2)-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E4%B8%8E%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/</id>
    <published>2022-10-15T14:35:23.000Z</published>
    <updated>2022-11-22T10:57:42.158Z</updated>
    
    <content type="html"><![CDATA[<h1 id="包的思想">包的思想</h1><h1 id="go命名规则">Go命名规则</h1><h2 id="命名要求">命名要求</h2><p>Go语言中的包名、函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则：一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。其中，大小写字母是不同的。</p><p>命名自然要避开关键字，以下为Go中的25个关键字：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">break      default       func     interface   select<br>case       defer         go       map         struct<br>chan       else          goto     package     switch<br>const      fallthrough   if       range       type<br>continue   for           import   return      var<br></code></pre></td></tr></table></figure><p>此外，还有大约三十多个预定义的名字包括内建常量、内建类型和内建函数等，命名时也应当避开。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">内建常量: true false iota nil<br><br>内建类型: int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr float32 float64 complex128 complex64 bool byte rune string error<br><br>内建函数: make len cap new append copy close delete complex real imag panic recover<br></code></pre></td></tr></table></figure><h2 id="公有和私有性">公有和私有性</h2><p>在Go中，通过字母大小写来控制包内常量、变量、类型、接口、结构、函数等的可见性的，名称以大写字母开头表示能被其它包访问或调用，以非大写字母(也可以是下划线)开头表示只能在包内使用。</p><p>如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span><span class="hljs-comment">//私有，无法被外部调用</span><br><span class="hljs-keyword">var</span> B <span class="hljs-type">string</span><span class="hljs-comment">//公开，可以被外部调用</span><br></code></pre></td></tr></table></figure><h2 id="命名规范">命名规范</h2><p>命名规范并不是go的强制要求，你不按照命名规范不会影响程序的运行。但是，遵循以下规范，会使程序更加有规范，可读性更强，被更多人所接受。</p><h3 id="文件">文件</h3><p>文件命名一律采用小写，不用驼峰式，尽量见名思义，看见文件名就可以知道这个文件下的大概内容。其中测试文件以test.go结尾，除测试文件外，命名不出现。</p><h3 id="包">包</h3><p>包名用小写，使用短命名，尽量不和标准库冲突。包名统一使用单数形式。</p><h3 id="变量">变量</h3><p>变量命名一般采用驼峰式，当遇到特有名词（缩写或简称，如DNS）的时候，特有名词根据是否私有全部大写或小写。</p><p>如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> apiClient <span class="hljs-type">int</span><span class="hljs-comment">//私有，无法被外部调用</span><br><span class="hljs-keyword">var</span> URLString <span class="hljs-type">string</span><span class="hljs-comment">//公开，可以被外部调用</span><br></code></pre></td></tr></table></figure><h3 id="常量">常量</h3><p>同变量规则，力求语义表达完整清楚，不要嫌名字长。如果模块复杂，为避免混淆，可按功能统一定义在package下的一个文件中。</p><h3 id="接口">接口</h3><p>单个函数的接口名以 er 为后缀</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">interface</span> &#123; Read(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) &#125;<br></code></pre></td></tr></table></figure><p>两个函数的接口名综合两个函数名，如:</p><p><code>type WriteFlusher interface &#123; Write([]byte) (int, error) Flush() error &#125;</code>三个以上函数的接口名类似于结构体名，如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Car <span class="hljs-keyword">interface</span> &#123; Start() Stop() Drive() &#125;<br></code></pre></td></tr></table></figure><h3 id="结构体">结构体</h3><p>结构体名应该是名词或名词短语，如<code>Account</code>,<code>Book</code>，避免使用<code>Manager</code>这样的。如果该数据结构需要序列化，如<code>json</code>，则首字母大写， 包括里面的字段。</p><h3 id="方法">方法</h3><p>方法名应该是动词或动词短语，采用驼峰式。将功能及必要的参数体现在名字中，不要嫌长， 如updateById，getUserInfo.如果是结构体方法，那么 Receiver的名称应该缩写，一般使用一个或者两个字符作为 Receiver 的名称。如果Receiver 是指针， 那么统一使用p。 如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f foo)</span></span> method() &#123; ... &#125;<span class="hljs-string">` `</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *foo)</span></span> method() &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>对于<code>Receiver</code>命名应该统一， 要么都使用值，要么都用指针。</p><h3 id="注释">注释</h3><p>每个包都应该有一个包注释，位于 package之前。如果同一个包有多个文件，只需要在一个文件中编写即可；如果你想在每个文件中的头部加上注释，需要在版权注释和Package前面加一个空行，否则版权注释会作为Package的注释。如：</p><p><code>// Copyright 2009 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. package net</code></p><p>每个以大写字母开头（即可以导出）的方法应该有注释，且以该函数名开头。如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Get 会响应对应路由转发过来的 get 请求 func (c *Controller) Get() &#123; ... &#125;</span><br></code></pre></td></tr></table></figure><p>大写字母开头的方法以为着是可供调用的公共方法，如果你的方法想只在本包内掉用，请以小写字母开发。如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Controller)</span></span> curl() &#123; ... &#125;<br></code></pre></td></tr></table></figure><p>注释应该用一个完整的句子，注释的第一个单词应该是要注释的指示符，以便查找。</p><p>注释应该以一个句点 <code>.</code> 结束。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;包的思想&quot;&gt;包的思想&lt;/h1&gt;
&lt;h1 id=&quot;go命名规则&quot;&gt;Go命名规则&lt;/h1&gt;
&lt;h2 id=&quot;命名要求&quot;&gt;命名要求&lt;/h2&gt;
&lt;p&gt;Go语言中的包名、函数名、变量名、常量名、类型名、语句标号和包名等所有的命名，都遵循一个简单的命名规则：一个名字必须以一个</summary>
      
    
    
    
    <category term="Go" scheme="https://nothingalr8.top/categories/Go/"/>
    
    <category term="从零开始的Go" scheme="https://nothingalr8.top/categories/Go/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go/"/>
    
    
    <category term="Go" scheme="https://nothingalr8.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的Go(1)-环境安装</title>
    <link href="https://nothingalr8.top/2022/10/14/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go(1)-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
    <id>https://nothingalr8.top/2022/10/14/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go(1)-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</id>
    <published>2022-10-14T05:35:23.000Z</published>
    <updated>2022-11-22T10:57:39.106Z</updated>
    
    <content type="html"><![CDATA[<h1 id="golang">Golang</h1><p>通过访问官网进行<a href="https://golang.google.cn/dl/">下载</a>。</p><h1 id="ide">IDE</h1><p>选择<code>Goland</code>或<code>VS Code</code></p><h2 id="goland">Goland</h2><p>前往<a href="https://www.jetbrains.com/go/">官网</a></p><p>Goland是一款收费的软件，但是如果你可以在官网申请学生认证，获得免费使用权。</p><h2 id="vs-code">VS Code</h2><p><a href="https://code.visualstudio.com/">官网</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;golang&quot;&gt;Golang&lt;/h1&gt;
&lt;p&gt;通过访问官网进行&lt;a href=&quot;https://golang.google.cn/dl/&quot;&gt;下载&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&quot;ide&quot;&gt;IDE&lt;/h1&gt;
&lt;p&gt;选择&lt;code&gt;Goland&lt;/code&gt;或&lt;co</summary>
      
    
    
    
    <category term="Go" scheme="https://nothingalr8.top/categories/Go/"/>
    
    <category term="从零开始的Go" scheme="https://nothingalr8.top/categories/Go/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go/"/>
    
    
    <category term="Go" scheme="https://nothingalr8.top/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>博客日志(3)-重建</title>
    <link href="https://nothingalr8.top/2022/10/13/%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%BF%97(3)-%E9%87%8D%E5%BB%BA/"/>
    <id>https://nothingalr8.top/2022/10/13/%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%BF%97(3)-%E9%87%8D%E5%BB%BA/</id>
    <published>2022-10-13T11:23:36.000Z</published>
    <updated>2022-11-22T10:57:27.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重建">重建</h1><p>我的博客被我玩坏了,无法修复,而重建就是我最好的选择,或许一开始,我就预料到了这个结局,但实际操纵起来,确实还是挺难受的,不如好好备份,避免重建。</p><p>重建的过程没有什么曲折,相当顺利,速度也比我第一次快了不少,而用Hexo建立博客的过程也让我发出感叹——好简单啊!这是我第一次建站没有的感受。</p><p>前不久,我通过了杭电助手二面的任务——用gin框架写一个简易的登录系统,我在这个过程中了解了不少网站的知识,这让我由衷的体会到了Hexo以及GitHubPage的便利。</p><p>用Hexo建立博客可以没有一点网站知识,只是通过教程一步步走,也可以顺利把网站建立起来。不用学习任何系统知识,不用编一句程序,不需要多么出色的布局设计......你所需要做的,只是安装node,npm以及hexo,并打几行指令。</p><p>而GitHubPage的便利,我是在部署网页到服务器上时体会到的。无需将配置文件转移到服务器,无需调试因为系统转移而产生的任何问题,无需重新安装环境,无需通过及其复杂以及耗时的网站备案(gtmd净网行动)。似乎国内也有类似GitHubPage一样的服务,但是好像也要备案了。</p><h1 id="新主题">新主题</h1><p>博客的重建也自然是迎来了新主题,我采用的是Fluid,主题比较简洁,也有暗色主题,比较符合我的审美。而主题也有较完善的使用指南,配置也非常方便。</p><p>主题的介绍我就不展开了,如果有兴趣,可以前往Fluid的<ahref="https://github.com/fluid-dev/hexo-theme-fluid">Github页面</a>与<ahref="https://hexo.fluid-dev.com/docs/">用户手册</a>。</p><h1 id="新评论系统">新评论系统</h1><p>评论,我原先使用的是Livere。也确实挺便利好用的,但是访问速度较慢,在暗色主题的适配上也会产生问题。所以,我一并把评论系统换了。</p><p>一开始,我是准备使用gitalk的,我的博客既然部署在GitHubPage上,就不用考虑gitalk的速度问题了。但是,在配置好gitalk后,gitalk评论始终加载不出来,我也尝试了多种方法去解决,最终也没有解决。</p><p>最后,我选择了valine,使用起来也较为简单,只是我对评论的头像不太满意,寻找的解决方法似乎也都不太行。后续我也许会使用其他评论。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;重建&quot;&gt;重建&lt;/h1&gt;
&lt;p&gt;我的博客被我玩坏了,无法修复,而重建就是我最好的选择,或许一开始,我就预料到了这个结局,但实际操纵起来,确实还是挺难受的,不如好好备份,避免重建。&lt;/p&gt;
&lt;p&gt;重建的过程没有什么曲折,相当顺利,速度也比我第一次快了不少,而用Hexo</summary>
      
    
    
    
    <category term="博客日志" scheme="https://nothingalr8.top/categories/%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="博客日志" scheme="https://nothingalr8.top/tags/%E5%8D%9A%E5%AE%A2%E6%97%A5%E5%BF%97/"/>
    
    <category term="hexo" scheme="https://nothingalr8.top/tags/hexo/"/>
    
    <category term="网站搭建" scheme="https://nothingalr8.top/tags/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>从零开始的Go(0)-前言</title>
    <link href="https://nothingalr8.top/2022/10/13/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go(0)-%E5%89%8D%E8%A8%80/"/>
    <id>https://nothingalr8.top/2022/10/13/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go(0)-%E5%89%8D%E8%A8%80/</id>
    <published>2022-10-13T05:35:23.000Z</published>
    <updated>2022-11-22T10:57:35.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><h1 id="关于go">关于Go</h1><h1 id="参考教程">参考教程</h1><ol type="1"><li><ahref="%5B《Go%20入门指南》%20%7C%20Go%20技术论坛%20(learnku.com)%5D(https://learnku.com/docs/the-way-to-go)">Go入门指南</a></li><li><ahref="%5BGo%20语言之旅%20(go-zh.org)%5D(https://tour.go-zh.org/welcome/1)">Go语言之旅</a></li><li><ahref="%5BGo%20语言教程%20%7C%20菜鸟教程%20(runoob.com)%5D(https://www.runoob.com/go/go-tutorial.html)">菜鸟教程</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;h1 id=&quot;关于go&quot;&gt;关于Go&lt;/h1&gt;
&lt;h1 id=&quot;参考教程&quot;&gt;参考教程&lt;/h1&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a
href=&quot;%5B《Go%20入门指南》%20%7C%20Go%20技术论坛%20(learnku.c</summary>
      
    
    
    
    <category term="Go" scheme="https://nothingalr8.top/categories/Go/"/>
    
    <category term="从零开始的Go" scheme="https://nothingalr8.top/categories/Go/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84Go/"/>
    
    
    <category term="Go" scheme="https://nothingalr8.top/tags/Go/"/>
    
  </entry>
  
</feed>
